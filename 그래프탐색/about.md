# 그래프 탐색

> 다수의 데이터 중에서 원하는 데이터를 찾는 과정

### 그래프 표현 방식

- 인접행렬(2차원배열) : 2차원 배열에 각 노드가 연결된 형태를 기록. 연결되지 않은 노드끼리는 초기값 할당(최소 최대에 따라 0 혹은 INF = 99999999)
- 인접리스트(리스트): 리스트로 그래프 연결 관계를 표현. C++은 `vector` 이용

**비교**

- 인접행렬 : 노드 개수가 많을수록 메모리 불필요하게 낭비됨. O(V^2)
- 인접리스트: 인접행렬보다 두 노드가 연결되어있는지에 대한 정보를 얻는 속도가 느림 O(V+E)
  ex)인접행렬: graph[1][2], 인접리스트는 node 1에 대한 인접리스트를 확인하면서 노드 7과 연결된 링크를 찾아야 함.
  => 특정한 노드와 연결된 모든 인접 노드를 수행해야하는 경우 => 인접 리스트 사용

코드 예시

```cpp
//인접 행렬
for(int i =0; i < N; i+){
    if(arr[v][i]) // 해당 간선이 존재하는지 확인 필요
}
//인접 리스트
for(int i = 0; i< list[v].size(); i++){
    dfs(list[v][i]);// 존재하는 간선 차례대로 적용
}
```

예를 들면 시작점이 1일 경우 인접 행렬은 0부터 ~1,2,3,4,....를 거치면서 1과 0이 연결된 간선이 있는지 확인하고 다음 정점을 선택하는 반면,
인접 리스트는 list[1] 배열에 들어있는 정점들 => 1과 연결된 정점 목록에서 하나를 골라 정점을 선택한다.
(인접 리스트 구현시 list.resize(N)해서 배열 크기 잡아줌)

대표적인 그래프 탐색 알고리즘으로는 DFS와 BFS가 있음.

# DFS vs BFS

## DFS(Depth-First Search)

- 깊이 우선 탐색
- 각 노드별로 가장 깊이 위치하는 노드에 닿을 때까지 확인
- 시간복잡도 O(N)

**적용 문제**

- 최소 비용

### 알고리즘 요약

🔑 스택 자료구조 혹은 재귀함수를 이용(재귀함수가 내부적으로 스택으로 이루어져 있기 때문)

1. 탐색 시작노드를 스택에 삽입 & 방문 처리
2. 스택의 최상단노드에 방문하지 않은 인접한 노드가 하나라도 있으면
   ? 해당 노드를 스택에 넣고 방문 처리
   : 스택에서 최상단 노드를 꺼냄
3. 2번 과정을 수행할 수 없을 때까지 반복

방문처리 : 한 번 탐색한 노드를 다시 탐색하지 않도록
**예시)**

```cpp
def dfs(graph, v, visited)
    visited[v] = 1;

    for i in graph[v] // 인접한 노드 사이즈만큼 탐색 graph[v].size()
        if not visited[i]:
            dfs(graph, i, visited)

dfs(graph,1,visited)
```

## BFS(Breadth First Search)

- 너비 우선 탐색
- 가까운 노드부터 우선 탐색
- 시간복잡도 O(N)

**적용 문제**

- 임의의 정점에서 시작해 모든 정점을 한번씩 방문하는 문제
- 최단 거리를 구하는 문제
- 모든 가중치가 1인 그래프 탐색 문제

### 알고리즘 요약

🔑 큐 이용

1. 탐색 시작 노드르 큐에 삽입 & 방문처리
2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 삽입 & 방문 처리
3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복

**예시)**

```cpp
def bfs(graph, start, visited)
    visited[start] = 1
    queue.push(start)

    while queue:
        v = queue.pop()
        for i in graph[v]:
            if not visited[i]:
                queue.push(i)
                visited[i] = 1;

bfs(graph,start,visited)
```

## 풀이 TIP

### 💡 Queue에 좌표 저장

```cpp
queue<pair<int,int>> q; //좌표 넣어줄 queue;
```

### 💡 상하좌우 탐색해야 하는 경우

> dx, dy 배열 만들어서 반목문 돌리기

```cpp
int dx[4] = {1,0,-1,0};  // 상하좌우 탐색 위한 dx,dy 이동 좌표
int dy[4] = {0,1,0,-1};
 for(int dir = 0; dir < 4; dir++){
    int nx = i + dx[dir];
    int ny = j + dy[dir];
    ...
 }

```
