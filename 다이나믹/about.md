# 다이나믹 프로그래밍(동적 계획법)

: 반복적으로 계산되는 것들의 계산 횟수를 줄이기 위한 알고리즘 ex) 피보나치 수열
계산된 결과는 저장해두어 다시 계산하지 않음

### 다이나믹 문제 조건

1. 최적 부분 구조
   : 큰 문제를 작은 문제로 나눌 수 있고, 작은 문제의 결과를 바탕으로 큰 문제를 해결 가능해야 함.
2. 중복되는 부분 문제
   : 동일한 작은 문제를 반복적으로 해결해야 하는 문제일 경우

- 피보나치 수열
- 최장 공통 부분 수열

## 풀이 방식

- Top-down, Bottom-up 방식으로 구현함.(보통 상향식으로 구현하는 편)
- 점화식을 세워서 계산
  <br> \* 규칙을 찾아서 점화식을 잘 세우는게 중점!

### Top-Down(하향식)

Top-Down 방식은 메모이제이션 방식이라고도 하며, 부분 문제의 결과들을 저장하여 사용한다.

```cpp
int fibo(int x){
    if(x <= 2) return 1;
    if(dp[x]) return dp[x];
    dp[x] = fibo(x-1) + fibo(x-2);
    return dp[x];
}
```

### Bottom-Up(상향식)

```cpp
dp[1] = 1;
dp[2] = 1;
for(int i = 3; i <=n; i++){
    dp[i] = dp[i-1] + dp[i-2];
}
```

## 알고리즘 요약

```cpp
for(int i = 0; i <=n; i++){
    if(i < 2){ // 점화식이 이전값을 참조하기 떄문에 배열 범위 밖의 요소는 별도 처리
        dp[i] = 1;
        continue;
    }
    dp[i] = dp[i-1] + dp[i-2]; // 점화식. 현재값 = 이전값으로부터 획득
}

dp[1] = 1; // 점화식이 이전 값을 참조하므로 배열 범위 밖의 요소들은 따로 정의 혹은 for문안에서 if문 처리
dp[2] = 1;
for(int i = 3; i <=n; i++){
    dp[i] = dp[i-1] + dp[i-2]; // 점화식. 현재값 = 이전값으로부터 획득
}
```

## 참고 풀이 방식

### 각 항목 별로 고려해야할 경우의 수가 있을 때

- RGB 문제나 쉬운 계단 수 문제 같이 각 항목 별로 고려해야할 경우의 수가 있는 경우
  ex) RGB 문제 : 각 집 별로 r/g/b, 쉬운 계단 수 : 각 항목 별로 0~9까지 고려

  > 2차원 배열로 풀이

  ```cpp
    arr[i][0]
    arr[i][1]
    arr[i][2]
    ...
  ```

### 각 항목 별로 무게, 마감기한 등 다른 항목 선택에 영향을 주는 값이 있는 경우

- 배낭 문제
- 퇴사 문제 등

아래와 같이 값을 인덱스로 사용

```cpp
dp[i + T[i]];
dp[i - W[i]];
```

### 배낭 문제

**배낭 문제 분류**

- 짐을 분리할 수 있는 경우(무게가 소수일 수 있는 경우) => 가능 배낭 문제(Fractional)
- 짐을 분리할 수 없는 경우(짐의 무게는 0이상의 정수) => 0-1 배낭 문제(0-1 Knapsack)

0-1 배낭 문제 점화식

```cpp
dp[i][j] = max(dp[i-1][j], dp[i-1][j-W[i] + v[i]]);
```
