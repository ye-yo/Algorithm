# 소수 구하기 - 에라토스테네스의 체

1. 숫자가 1보다 작거나 같으면 함수 종료
2. 2부터 n까지 n-1개를 저장할 수 있는 배열 할당
   배열 참조 번호와 소수가 일치하도록 배열의 크기는 n+1 길이만큼 할당(인덱스 번호 0과 1은 사용하지 않음)  
3. 배열초기화: 처음엔 모두 소수로 보고 true값을 줌

4. 에라토스테네스의 체에 맞게 소수를 구함
   만일, PrimeArray[i]가 true이면 i 이후의 i 배수는 약수로 i를 가지고 있는 것이 되므로 i 이후의 i 배수에 대해 false값을 준다.  
   PrimeArray[i]가 false이면 i는 이미 소수가 아니므로 i의 배수 역시 소수가 아니게 된다. 그러므로 검사할 필요도 없다.  
   또한 i*k (k < i) 까지는 이미 검사되었으므로 j시작 값은 i*2에서 i\*i로 개선할 수 있다.  

```cpp
void Eratos(int n)
{

    if (n <= 1) return;

	bool* PrimeArray = new bool[n + 1];


	for (int i = 2; i <= n; i++)
	    PrimeArray[i] = true;


	for (int i = 2; i * i <= n; i++)
	{
		if (PrimeArray[i])
			for (int j = i * i; j <= n; j += i)
			    PrimeArray[j] = false;
	}

}
```

# 최대공약수 & 최소공배수 구하기 - 유클리드 호제법 O(logN)

> 참고  
> 최대공약수 GCD(greatest common divisor)  
> 최대공배수 LCM(Least common multiple)

## 최대공약수

1071과 1029의 최대공약수를 구하면,  

- 1071은 1029로 나누어 떨어지지 않기 때문에, 1071을 1029로 나눈 나머지를 구한다. ≫ 42
- 1029는 42로 나누어 떨어지지 않기 때문에, 1029를 42로 나눈 나머지를 구한다. ≫ 21
- 42는 21로 나누어 떨어진다.

따라서, 최대공약수는 21이다.  

1. 두 수가 입력으로 들어온다.(m > n)
2. 작은수(n)가 0이라면, 큰수(m)을 출력하고 알고리즘을 종료한다.
3. 큰수(m)가 작은수(n)로 나누어 떨어지면, 작은수(n)을 출력하고 알고리즘을 종료한다.
   그렇지 않으면,  
   큰수(m)를 작은수(n)로 나눈 **나머지**를 새롭게 큰수(m)에 대입하고, 큰수(m)와 작은수(n)를 바꾸고 3번을 반복한다.  
   = 큰수(m)를 작은수(n)로 나눈 나머지를 작은수(n)에 대입하고 큰수에 작은수를 대입하는 것과 동일  

```cpp
int gcd(int a, int b)
{
	return b ? gcd(b, a%b) : a;
}
int gcd(int a, int b)
{
    int c;
	while(b) // 작은수가 0이되면 나누어 떨어진 것이므로 종료
	{
		c = a % b; //큰수를 작은 수로 나누었을 때 나머지 = c
		a = b;//큰수에 작은수를 대입
		b = c;//작은 수에 나머지를 대입
	}
    return a;
}
```

## 최소공배수

공식 `최소공배수 * 최대공약수 = a * b`을 바탕으로 최대공약수 알고리즘을 이용하여 구한다.  
최소공배수 = a \* b / 최대공약수  

```cpp
int gcd(int a, int b){
	while(b!=0){
		int r = a%b;
		a= b;
		b= r;
	}
	return a;
}

int lcm(int a, int b){
    return a * b / gcd(a,b);
}
```

## 조합

`nCr` : 순서 상관없이 n개에서 r개 고르기  

```cpp
s = 1
for i in v: # 종류 중에 하나를 고름
    s *= i
s-- # 하나도 고르지 않은 경우는 제외
return s
```

해석  
만약 조합할 종류가 A 3개, B 2개, C 2개라면.  
`A 총 4개(안사용포함) * B (안사용포함) * C(안사용포함) -1(전부안사용)`  
